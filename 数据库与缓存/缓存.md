# 缓存

说到缓存就不得不说道redis, 就不得不说到各种缓存常规发生的问题

## 缓存穿透

* 它的含义指的是**查询一个并不存在的数据(持久层也不存在)**,由于缓存是被动写的,其来源是持久层的数据.
* 这样的场景就导致每次都会在缓存层不存在,每次都会去查询持久层,但每次都没法缓存
* 如果攻击者故意对这种数据进行并发请求,会造成后端DB压力剧增且会有压垮的风险

解决方案:

1. 如果持久层查询数据为空,也缓存起来,不过时间不是很长,只有5分钟这样子
2. 采用布隆过滤器,将所有可能存在的数据(即每次查询有结果的数据)hash到一个bitmap中,如果不存在的数据是过不了这个检验的,我们将不会查询数据库

## 缓存雪崩

* 缓存雪崩是指在我们设置缓存时**采用了相同的过期时间**，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
* 常规来说一个key数据的持久化查询我们会只让一个线程执行,但很多个key同时失效需要查询时就会压垮DB了

解决方案:

1. 简单方案: 每个key数据的缓存时间不仅有固定时间,还要加上一个随机的时间(eg: 1~5 min)
2. 同一个key的持久化查询只让一个线程去做,其他线程等然后拿取信息就好

## 缓存击穿

其实跟雪崩的区别是, 雪崩是很多key失效,击穿是一个key失效,而这个key又有超高的并发

解决方案

1. 同样是要锁定查询,只让一个线程去做,如果是单机就使用java自己的锁模式,lock.tryLock,sychronized; 如果是分布式就使用分布式锁, setnx, 有且只有一个人抢到, 这个人就去查, 其他人等着, 其他人拿到锁后检查是否有数据,有返回即可

## Redis

1. redis是基于内存进行逻辑操作的,逻辑速度处理超快( key -> 查询内存数据 -> 序列化出结构 )
2. Redis是单线程的,省去很多上下文切换线程的时间

原因:

* redis能够6W/1S的吞吐量,1S中有0.90S是花费在网络IO上的, 它自己的逻辑处理时间只有0.1S,使用多线程知会减少redis的逻辑处理,而其逻辑处理是及其简单的(CPU占用少)
* Redis如果使用多线程进行逻辑处理优化,即其单个逻辑处理会从0.00001优化到0.000001,但带来上下文切换增加的时间0.001S,这样**一个请求的处理时间就被增加了,且编程变得复杂**
